Welcome to the __Fertilized Forests__ API documentation!

## Naming conventions

Every header contains only a single class definition. The header name is
lowercase, the class names are usually CamelCase. Helper class names start
with an underscore.

All files that have a filename starting with two
underscores are automatically generated by the CodeGenerator project.
However, there are files generated by the CodeGenerator that have a
usual name, because they are meant to be included by library end-users.

## Defined symbols

* `BUILD_FERTILIZED_LIBRARY`: Defined when building the fertilized core
   project. Effects: DllExport is defined to be `__declspec(dllexport)`
   for the MSVC compiler.
* `PYTHON_ENABLED`: If defined, Python specific extensions such as GIL
   releases are done in the main library. It is defined if the flag
   `--with-python-support` is used for building with SCons or if the
   `--with-python` flag is used, that triggers building the Python
   interface.
* `SERIALIZATION_ENABLED`: If this symbol is defined, all serialization
   methods of the library can be used. This adds a dependendy on boost
   serialization. It is automatically defined by the build system if the flag
   `--with-serialization`  is used.
* `CAFFE_CPU_ONLY`: Defined, if only the CPU build of caffe is used to be
   linked against.
* `WITH_OPENCV`: If defined, the feature extraction methods for images are
   built, otherwise they are omitted.

## Pointers

Pointer or reference object passing is used whereever possible. For two
reasons, there are mostly `shared_ptr`s and not `unique_ptr`s used:
* The Python and Matlab interface: objects are shared between the C++ objects and the Python/MATLAB runtime.
* Serialization: the container constructors (e.g. `map`) of boost serialization are not yet (v1.54) updated to use `move` instead of `copy`. This makes it impossible to use a container of `unique_ptr`s.

## Parallelization

For fine-grained parallelization support, the following objects must be thread-safe:

* The method ISurfaceCalculator::propose_params
* ISurfaceCalculator::calculate
* IThresholdOptimizer::optimize

## Extending the library

If you want to add a class and use it with the various interfaces, simply add an interface specification section to its doxygen documentation like this:

     * -----
     * Available in:
     * - C++
     * - Python
     * - Matlab
     * .
     * Instantiations:
     * - float; float
     * - uint; uint
     * .
     * Exported name: MyMethod
     * Soil type always:
     * - uint; uint
     * .
     *
     * -----


Notice the dots and the blank line before the closing `-----` to make the section render correctly in doxygen. Only the`Available in:` part is strictly necessary: it specifies, to which interfaces the class is added by the CodeGenerator.

If the class has template parameters, use the `Instantiations:` section to specify which template instantiations should be produced. __Be aware__: currently it is only possible to use at maximum the template parameters with the names `input_dtype`, `feature_dtype`, `annotation_dtype`, `leaf_return_dtype`, `forest_return_dtype`.

With the part `Exported name:` it is possible to explicitely specify a name for a Method to avoid name clashes (e.g. because of overloads).

If `Soil type always` is specified, the soil instantiation types are ignored and always this templated type is instantiated.

Don't forget that it is not enough to add this section to the class! It is also necessary to add it at least to one Constructor, to make it available!
